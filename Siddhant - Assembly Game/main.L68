00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.04
Created On: 1/4/2017 3:28:42 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : Doge Ball
00000000                             3  * Written by : Siddhant Grover
00000000                             4  * Date       : 10 / 03 / 2016
00000000                             5  * Description: A game based on dodging projectiles using arrow keys
00000000                             6  *-----------------------------------------------------------
00001000                             7  START    ORG    $1000
00001000                             8  
00001000  =25262728                  9  ARROW_KEYS_INPUT                    EQU     $25262728
00001000  =00000020                 10  SPACE_INPUT                         EQU     $20
00001000                            11  
00001000  =00000013                 12  GET_PLAYER_INPUT_TRAP_CODE          EQU     19
00001000  =00000008                 13  TIME_SINCE_MIDNIGHT_TRAP_CODE       EQU      8
00001000  =0000005C                 14  DRAWING_MODE_TRAP_CODE              EQU     92
00001000  =0000005E                 15  REPAINT_SCREEN_TRAP_CODE            EQU     94
00001000  =00000049                 16  PLAY_SOUND_TRAP_CODE                EQU     73
00001000  =00000009                 17  HALT_SIM_TRAP_CODE                  EQU      9
00001000                            18  
00001000  =00000028                 19  DEVIATION_IN_PATH                   EQU     40      ; The range of deviation a ball can have in it's path after spawnnning is 40(-20 to 20). Correspoinding deviation velocities are -1.25 and 1.25
00001000                            20  
00001000                            21  ; EXECUTION STARTS HERE
00001000  4EB9 000010D2             22      jsr     enableDoubleBuffering
00001006                            23  ; Push the conditions for displaying the start screen onto the stack
00001006  2F3C 00000000             24      move.l  #0, -(sp)   
0000100C  2F3C 00000000             25      move.l  #0, -(sp)   
00001012  2F3C 000001E0             26      move.l  #480, -(sp)
00001018  2F3C 00000280             27      move.l  #640, -(sp)
0000101E  2F3C 00000000             28      move.l  #0, -(sp)
00001024  2F3C 00000000             29      move.l  #0, -(sp)
0000102A  2F3C 000C439C             30      move.l  #startScreen, -(sp) 
00001030  4EB9 000018B2             31      jsr loadImage      
00001036  DFFC 0000001C             32      add.l   #28, sp  
0000103C                            33  ; Repaint the display
0000103C  103C 005E                 34      move.b  #REPAINT_SCREEN_TRAP_CODE, d0
00001040  4E4F                      35      trap    #15
00001042                            36  ; Start the game once player presses space bar    
00001042                            37  waitForGameStart:
00001042  7220                      38      move.l  #SPACE_INPUT, d1
00001044  7013                      39      move.l  #GET_PLAYER_INPUT_TRAP_CODE, d0
00001046  4E4F                      40      trap    #15
00001048  0281 FFFFFFFF             41      andi.l  #$FFFFFFFF, d1
0000104E  67F2                      42      beq     waitForGameStart
00001050                            43  ; Loading game associated data and setting up the game
00001050  4EB9 000010DA             44      jsr     loadBackground
00001056  4EB9 00001112             45      jsr     initializeVariables
0000105C  4EB9 000011B0             46      jsr     loadPlayer
00001062  4EB9 00001A1A             47      jsr     seedRandomNumber
00001068                            48      
00001068                            49  gameLoop:
00001068                            50  ; Check if game should continue to run, i.e. lose condition isn't triggered
00001068  1039 0010F825             51      move.b  GAME_LOST, d0
0000106E  6600 0178                 52      bne     gameLoseCondition   
00001072  4EB9 0000125A             53      jsr     estimateDeltaTime                       ; Estimate change in time since previous frame, i.e. deltaTime
00001078  4EB9 00001274             54      jsr     getArrowKeysInput                       ; Check for inputs from arrow keys
0000107E                            55  ; Debounce player input    
0000107E  2239 0010F7D2             56      move.l  playerInput, d1
00001084  0281 FFFFFFFF             57      andi.l  #$FFFFFFFF, d1
0000108A  6700 001E                 58      beq     noInput                                 ; In case there is no arrow key input at all, i.e. all keys are released    
0000108E  1039 0010F81F             59      move.b  HAVE_HAD_NO_INPUT, d0
00001094  6700 001C                 60      beq     aroundNoInput                            
00001098  13FC 0000 0010F81F        61      move.b  #0, HAVE_HAD_NO_INPUT                   ; Reset the flag since input is being processed
000010A0                            62  ; Process player input
000010A0  4EB9 00001286             63      jsr     setPlayerVelocity                       ; Depending on the input, sets the players velocity appropriately
000010A6  6000 000A                 64      bra     aroundNoInput
000010AA                            65  noInput:
000010AA  13FC 0001 0010F81F        66      move.b  #1, HAVE_HAD_NO_INPUT                   ; Set the flag for no inputs
000010B2                            67      
000010B2                            68  aroundNoInput:
000010B2                            69  ; Update gameplay elements which are independent of input
000010B2  4EB9 0000130C             70      jsr     updatePlayerOnDisplay                   ; If the player is moving, clear and redraw the player. Also, decelerates the player
000010B8  4EB9 000014C8             71      jsr     instantiateBall                         ; If there is no ball in play, instantiate one at a random location
000010BE  4EB9 000016A0             72      jsr     updateBallOnDisplay                     ; Clears and redraws the ball after updating it's position
000010C4                            73  ; Now that the positions have been updated, collision are accounted for
000010C4  4EB9 000017FE             74      jsr     checkForCollision
000010CA                            75  ; Render display
000010CA  103C 005E                 76      move.b  #REPAINT_SCREEN_TRAP_CODE, d0
000010CE  4E4F                      77      trap    #15
000010D0                            78  
000010D0  6096                      79      bra     gameLoop                                ; Repeat the game loop once the frame is rendered to display
000010D2                            80  
000010D2                            81  ;-------SUBROUTINE-------
000010D2                            82  enableDoubleBuffering:
000010D2  7211                      83      move.l  #17, d1
000010D4  705C                      84      move.l  #DRAWING_MODE_TRAP_CODE, d0
000010D6  4E4F                      85      trap    #15
000010D8  4E75                      86      rts
000010DA                            87  
000010DA                            88  ;-------SUBROUTINE-------
000010DA                            89  loadBackground:
000010DA                            90  ; Push the conditions for displaying background onto the stack
000010DA  2F3C 00000000             91      move.l  #0, -(sp)   
000010E0  2F3C 00000000             92      move.l  #0, -(sp)   
000010E6  2F3C 000001E0             93      move.l  #480, -(sp)
000010EC  2F3C 00000280             94      move.l  #640, -(sp)
000010F2  2F3C 00000000             95      move.l  #0, -(sp)
000010F8  2F3C 00000000             96      move.l  #0, -(sp)
000010FE  2F3C 00001BC4             97      move.l  #gameBackground, -(sp) 
00001104                            98      
00001104  4EB9 000018B2             99      jsr loadImage                                   ; Call image rendering subroutine        
0000110A  DFFC 0000001C            100      add.l   #28, sp                                 ; Reset the stack pointer    
00001110  4E75                     101      rts
00001112                           102  
00001112                           103  ;-------SUBROUTINE-------
00001112                           104  initializeVariables:
00001112                           105  ; Player spawns at the center of the display
00001112  23FC 000000D0 0010F7DA   106      move.l  #208, playerPositionY                   ; Top left corner of the player such that the center of the player is at the center of display when the player is spawned
0000111C  23FC 00000120 0010F7D6   107      move.l  #288, playerPositionX 
00001126  23FC 000001E0 0010F7EA   108      move.l  #480, ballPositionY                     ; Moving the ball out of display initially
00001130  23FC 00000280 0010F7E6   109      move.l  #640, ballPositionX   
0000113A                           110  ; Player's velocity should be 0
0000113A  23FC 00000000 0010F7DE   111      move.l  #0, playerVelocityX
00001144  23FC 00000000 0010F7E2   112      move.l  #0, playerVelocityY
0000114E  23FC 00000000 0010F7EE   113      move.l  #0, ballVelocityX
00001158  23FC 00000000 0010F7F2   114      move.l  #0, ballVelocityY    
00001162                           115  ; All the input booleans should be 0
00001162  13FC 0000 0010F820       116      move.b  #0, UP_INPUT
0000116A  13FC 0000 0010F821       117      move.b  #0, DOWN_INPUT
00001172  13FC 0000 0010F822       118      move.b  #0, LEFT_INPUT
0000117A  13FC 0000 0010F823       119      move.b  #0, RIGHT_INPUT
00001182                           120  ; Initialize time associated variables
00001182  33FC 0000 0010F7FA       121      move.w  #0, deltaTime
0000118A  7008                     122      move.l  #TIME_SINCE_MIDNIGHT_TRAP_CODE, d0
0000118C  4E4F                     123      trap    #15
0000118E  23C1 0010F7FC            124      move.l  d1, currentFrameTime     
00001194                           125  ; Initialize other variables
00001194  13FC 0001 0010F824       126      move.b  #1, BALL_ISNT_IN_PLAY    
0000119C  13FC 0000 0010F825       127      move.b  #0, GAME_LOST
000011A4  23FC 00000000 0010F7F6   128      move.l  #0, score
000011AE  4E75                     129      rts    
000011B0                           130  
000011B0                           131  ;-------SUBROUTINE-------
000011B0                           132  loadPlayer:
000011B0  2F39 0010F7DA            133      move.l  playerPositionY, -(sp)   
000011B6  2F39 0010F7D6            134      move.l  playerPositionX, -(sp)   
000011BC  2F3C 00000040            135      move.l  #64, -(sp)
000011C2  2F3C 00000040            136      move.l  #64, -(sp)
000011C8  2F3C 00000000            137      move.l  #0, -(sp)
000011CE  2F3C 00000000            138      move.l  #0, -(sp)
000011D4  2F3C 000772FA            139      move.l  #playerSprite, -(sp) 
000011DA                           140  
000011DA  4EB9 000018B2            141      jsr loadImage                                   ; Call image loading subroutine        
000011E0  DFFC 0000001C            142      add.l   #28, sp                                 ; Reset the stack pointer    
000011E6  4E75                     143      rts
000011E8                           144      
000011E8                           145      
000011E8                           146  ; Perform operations for player lose condition
000011E8                           147  gameLoseCondition:
000011E8                           148  ; Clear sprites from display
000011E8  4EB9 0000133A            149      jsr     clearPlayerFromDisplay
000011EE  4EB9 000016BA            150      jsr     clearBallFromDisplay
000011F4  4EB9 00001222            151      jsr     loadEndScreen                           ; Loads the end screen sprite
000011FA                           152  ; Display score
000011FA  2F3C 0000000D            153      move.l  #13, -(sp)
00001200  2F3C 0000015E            154      move.l  #350, -(sp)
00001206  2F39 0010F7F6            155      move.l  score, -(sp)
0000120C  4EB9 00001A4E            156      jsr     displayNumberOnLEDs
00001212  DFFC 0000000C            157      add.l   #12, sp
00001218                           158  ; Render display
00001218  103C 005E                159      move.b  #REPAINT_SCREEN_TRAP_CODE, d0
0000121C  4E4F                     160      trap    #15
0000121E                           161  ; Halt the simulator   
0000121E  7009                     162      move.l  #HALT_SIM_TRAP_CODE, d0
00001220  4E4F                     163      trap    #15
00001222                           164  ;-------SUBROUTINE-------
00001222                           165  loadEndScreen:
00001222                           166  ; Push the conditions for displaying the end game screen onto the stack
00001222  2F3C 00000000            167      move.l  #0, -(sp)   
00001228  2F3C 00000000            168      move.l  #0, -(sp)   
0000122E  2F3C 000001E0            169      move.l  #480, -(sp)
00001234  2F3C 00000280            170      move.l  #640, -(sp)
0000123A  2F3C 00000000            171      move.l  #0, -(sp)
00001240  2F3C 00000000            172      move.l  #0, -(sp)
00001246  2F3C 00078F66            173      move.l  #endScreen, -(sp) 
0000124C                           174  ; Call the image rendering subroutine    
0000124C  4EB9 000018B2            175      jsr loadImage      
00001252  DFFC 0000001C            176      add.l   #28, sp  
00001258  4E75                     177      rts
0000125A                           178  ;-------SUBROUTINE-------
0000125A                           179  estimateDeltaTime:    
0000125A  2439 0010F7FC            180      move.l  currentFrameTime, d2
00001260  7008                     181      move.l  #TIME_SINCE_MIDNIGHT_TRAP_CODE, d0
00001262  4E4F                     182      trap    #15
00001264  23C1 0010F7FC            183      move.l  d1, currentFrameTime                    ; Save time for the current frame
0000126A  9282                     184      sub.l   d2, d1                                  ; Change in time since last frame
0000126C  33C1 0010F7FA            185      move.w  d1, deltaTime
00001272  4E75                     186      rts
00001274                           187  
00001274                           188  ;-------SUBROUTINE-------    
00001274                           189  getArrowKeysInput:
00001274  223C 25262728            190      move.l  #ARROW_KEYS_INPUT, d1                   ; Checking arrow keys for input
0000127A  7013                     191      move.l  #GET_PLAYER_INPUT_TRAP_CODE, d0
0000127C  4E4F                     192      trap    #15
0000127E                           193      
0000127E  23C1 0010F7D2            194      move.l  d1, playerInput                         ; Save the input by player 
00001284  4E75                     195      rts
00001286                           196      
00001286                           197  ;-------SUBROUTINE------- 
00001286                           198  setPlayerVelocity:
00001286                           199  ; This method sets the players velocity and plays the jump sound (Sound subroutines are at the end of all subroutines)
00001286                           200  ; Velocities are represented using fixed point arithmetic, such that:
00001286                           201  ; 1-bit represents the sign
00001286                           202  ; 27-bits represent the magnitude
00001286                           203  ; 4-bits represent the fraction
00001286                           204  ; Speed of player is 4. Thus, 4 * (16) = 64 is the magnitude for this representation
00001286                           205  
00001286  2039 0010F7D2            206      move.l  playerInput, d0                         ; Access player input
0000128C                           207  ; Conditions for UP movement
0000128C  2200                     208      move.l  d0, d1
0000128E  0281 00FF0000            209      andi.l  #$00FF0000, d1
00001294  6700 0014                210      beq     upKeyNotPressed                         ; If up key isn't pressed, don't add velocity along -ve Y.
00001298  13FC 0001 0010F820       211      move.b  #1, UP_INPUT                            ; Set the corresponding input flag
000012A0  04B9 00000040 0010F7E2   212      sub.l   #64, playerVelocityY                    ; This method is only called once velocity is 0, so it essentially moving the value.
000012AA                           213  upKeyNotPressed:    
000012AA                           214  ; Conditions for DOWN movement
000012AA  2200                     215      move.l  d0, d1
000012AC  0281 000000FF            216      andi.l  #$000000FF, d1
000012B2  6700 0014                217      beq     downKeyNotPressed                       ; If down key isn't pressed, don't add velocity along +ve Y.
000012B6  13FC 0001 0010F821       218      move.b  #1, DOWN_INPUT
000012BE  06B9 00000040 0010F7E2   219      add.l  #64, playerVelocityY
000012C8                           220  downKeyNotPressed:
000012C8                           221  ; Conditions for LEFT movement
000012C8  2200                     222      move.l  d0, d1
000012CA  0281 FF000000            223      andi.l  #$FF000000, d1
000012D0  6700 0014                224      beq     leftKeyNotPressed                       ; If left key isn't pressed, don't add velocity along -ve X.
000012D4  13FC 0001 0010F822       225      move.b  #1, LEFT_INPUT
000012DC  04B9 00000040 0010F7DE   226      sub.l  #64, playerVelocityX
000012E6                           227  leftKeyNotPressed:    
000012E6                           228  ; Conditions for RIGHT movement
000012E6  2200                     229      move.l  d0, d1
000012E8  0281 0000FF00            230      andi.l  #$0000FF00, d1
000012EE  6700 0014                231      beq     rightKeyNotPressed                      ; If right key isn't pressed, don't add velocity along +ve X.
000012F2  13FC 0001 0010F823       232      move.b  #1, RIGHT_INPUT
000012FA  06B9 00000040 0010F7DE   233      add.l  #64, playerVelocityX
00001304                           234  rightKeyNotPressed:    
00001304  4EB9 000018A6            235      jsr     playJumpSound                           
0000130A  4E75                     236      rts
0000130C                           237  ;-------SUBROUTINE-------    
0000130C                           238  updatePlayerOnDisplay:
0000130C                           239  ; If player has any speed, clear and redraw the player at updated position.
0000130C  2039 0010F7DE            240      move.l  playerVelocityX, d0
00001312  80B9 0010F7E2            241      or.l    playerVelocityY, d0
00001318  6700 0018                242      beq     noChangeInPlayerPosition                ; If player isn't moving, skip updating player
0000131C                           243      
0000131C  4EB9 0000133A            244      jsr     clearPlayerFromDisplay                  ; Removes the previously rendered player position
00001322  4EB9 00001372            245      jsr     updatePlayerVelocity                    ; Decelerates the player to mimic jumping action
00001328  4EB9 0000145A            246      jsr     updatePlayerPosition                    ; Updates the players position based on current speed of player    
0000132E  4EB8 11B0                247      jsr     loadPlayer                              ; Renders player at the updated position
00001332                           248      
00001332                           249  noChangeInPlayerPosition:
00001332  4EB9 00001484            250      jsr     checkPlayerPosition                     ; Check if the player left the play area, if so, set lose condition boolean
00001338  4E75                     251      rts
0000133A                           252  ;-------SUBROUTINE-------    
0000133A                           253  clearPlayerFromDisplay:
0000133A                           254  ; Clears the player by redrawing a chunk of background over the player
0000133A  2F39 0010F7DA            255      move.l  playerPositionY, -(sp)                  ; Y-Position on output display
00001340  2F39 0010F7D6            256      move.l  playerPositionX, -(sp)                  ; X-Position on output display
00001346  2F3C 00000040            257      move.l  #64, -(sp)                              ; Height to display
0000134C  2F3C 00000040            258      move.l  #64, -(sp)                              ; Width to display
00001352  2F39 0010F7DA            259      move.l  playerPositionY, -(sp)                  ; Y-Position in source image
00001358  2F39 0010F7D6            260      move.l  playerPositionX, -(sp)                  ; X-Position in source image
0000135E  2F3C 00001BC4            261      move.l  #gameBackground, -(sp)                  ; Pointer to game background
00001364                           262  
00001364  4EB9 000018B2            263      jsr loadImage                                   ; Call image loading subroutine        
0000136A  DFFC 0000001C            264      add.l   #28, sp                                 ; Reset the stack pointer    
00001370  4E75                     265      rts
00001372                           266  
00001372                           267  ;-------SUBROUTINE------- 
00001372                           268  updatePlayerVelocity:
00001372                           269  ; Deceleration is 0.125
00001372                           270  ; In fixed point arithmetic with 4 fractional bits, deceleration is:
00001372                           271  ; 0.125 * (16) = 2
00001372                           272  
00001372                           273  ; Reduce velocity if the player is moving upwards, i.e, if the initial input for the jump was upwards.    
00001372  1039 0010F820            274      move.b  UP_INPUT, d0
00001378  6700 0024                275      beq     noChangeInUpVelocity                ; If there is no up key input, continue with block
0000137C  2039 0010F7E2            276      move.l  playerVelocityY, d0
00001382  6700 001A                277      beq     noChangeInUpVelocity                ; If velocity along Y is 0, then skip deceleration
00001386  0C80 FFFFFFFF            278      cmpi.l  #$FFFFFFFF, d0
0000138C  6E00 00BE                279      bgt     resetPlayerVelocityY                ; If velocity along Y is greater than -1, then reset it to 0
00001390  7202                     280      move.l  #2, d1                              ; deceleration is 2 in fixed point arithmetic
00001392  C3F9 0010F7FA            281      muls.w  deltaTime, d1                       ; deceleration * time = change in velocity
00001398  D3B9 0010F7E2            282      add.l   d1, playerVelocityY                 ; Final velocity is stored
0000139E                           283  noChangeInUpVelocity:
0000139E                           284  ; Reduce velocity if the player is moving downwards.    
0000139E  1039 0010F821            285      move.b  DOWN_INPUT, d0
000013A4  6700 0024                286      beq     noChangeInDownVelocity
000013A8  2039 0010F7E2            287      move.l  playerVelocityY, d0
000013AE  6700 001A                288      beq     noChangeInDownVelocity
000013B2  0C80 00000001            289      cmpi.l  #1, d0
000013B8  6D00 0092                290      blt     resetPlayerVelocityY                ; This is done to ensure that the player's direction of motion doesn't change
000013BC  7202                     291      move.l  #2, d1
000013BE  C3F9 0010F7FA            292      muls.w  deltaTime, d1
000013C4  93B9 0010F7E2            293      sub.l   d1, playerVelocityY
000013CA                           294  noChangeInDownVelocity:    
000013CA                           295  ; Increase velocity if the player is moving leftwards.    
000013CA  1039 0010F822            296      move.b  LEFT_INPUT, d0
000013D0  6700 0024                297      beq     noChangeInLeftVelocity
000013D4  2039 0010F7DE            298      move.l  playerVelocityX, d0
000013DA  6700 001A                299      beq     noChangeInLeftVelocity
000013DE  0C80 FFFFFFFF            300      cmpi.l  #$FFFFFFFF, d0
000013E4  6E00 0058                301      bgt     resetPlayerVelocityX
000013E8  7202                     302      move.l  #2, d1
000013EA  C3F9 0010F7FA            303      muls.w  deltaTime, d1
000013F0  D3B9 0010F7DE            304      add.l   d1, playerVelocityX
000013F6                           305  noChangeInLeftVelocity:  
000013F6                           306  ; Decrease velocity if the player is moving rightwards.    
000013F6  1039 0010F823            307      move.b  RIGHT_INPUT, d0
000013FC  6700 0024                308      beq     noChangeInRightVelocity
00001400  2039 0010F7DE            309      move.l  playerVelocityX, d0
00001406  6700 001A                310      beq     noChangeInRightVelocity
0000140A  0C80 00000001            311      cmpi.l  #1, d0
00001410  6D00 002C                312      blt     resetPlayerVelocityX                
00001414  7202                     313      move.l  #2, d1
00001416  C3F9 0010F7FA            314      muls.w  deltaTime, d1
0000141C  93B9 0010F7DE            315      sub.l   d1, playerVelocityX
00001422                           316  noChangeInRightVelocity:    
00001422                           317  ; Check if speed is 0
00001422  2039 0010F7DE            318      move.l  playerVelocityX, d0                      
00001428  2239 0010F7E2            319      move.l  playerVelocityY, d1
0000142E  8081                     320      or.l    d1, d0
00001430  6700 0446                321      beq     resetInputBooleans                  ; At end of jump, i.e speed is 0, reset input booleans
00001434                           322  ; This reset is done to ensure that the player can't provide input unless a jump is complete, i.e. the speed is 0
00001434  13FC 0000 0010F81F       323      move.b  #0, HAVE_HAD_NO_INPUT
0000143C  4E75                     324      rts
0000143E                           325  
0000143E                           326  resetPlayerVelocityX:
0000143E  23FC 00000000 0010F7DE   327      move.l  #0, playerVelocityX
00001448  6000 FF28                328      bra     updatePlayerVelocity
0000144C                           329      
0000144C                           330  resetPlayerVelocityY:
0000144C  23FC 00000000 0010F7E2   331      move.l  #0, playerVelocityY
00001456  6000 FF1A                332      bra     updatePlayerVelocity  
0000145A                           333    
0000145A                           334  ;-------SUBROUTINE------- 
0000145A                           335  updatePlayerPosition:
0000145A  2039 0010F7DE            336      move.l  playerVelocityX, d0
00001460  C1F9 0010F7FA            337      muls.w  deltaTime, d0
00001466  E880                     338      asr.l   #4, d0                                  ; Since the velocity term has 4 fractional bits, we divide by 16
00001468  D1B9 0010F7D6            339      add.l   d0, playerPositionX
0000146E  2039 0010F7E2            340      move.l  playerVelocityY, d0
00001474  C1F9 0010F7FA            341      muls.w  deltaTime, d0
0000147A  E880                     342      asr.l   #4, d0                                  ; Since the velocity term has 4 fractional bits, we divide by 16
0000147C  D1B9 0010F7DA            343      add.l   d0, playerPositionY
00001482  4E75                     344      rts
00001484                           345      
00001484                           346  ;-------SUBROUTINE------- 
00001484                           347  checkPlayerPosition:
00001484  0CB9 FFFFFFFD 0010F7D6   348      cmpi.l  #$FFFFFFFD, playerPositionX         ; Condition for player to touch the left edge -4 (0 - 4)
0000148E  6D00 002E                349      blt     playerOutOfDisplay
00001492  0CB9 00000243 0010F7D6   350      cmpi.l  #579, playerPositionX               ; Condition for player to touch the right edge 580 (640 - 60)
0000149C  6E00 0020                351      bgt     playerOutOfDisplay
000014A0  0CB9 FFFFFFF9 0010F7DA   352      cmpi.l  #$FFFFFFF9, playerPositionY         ; Condition for player to touch the top edge 8 (0 - 8)
000014AA  6D00 0012                353      blt     playerOutOfDisplay
000014AE  0CB9 0000019F 0010F7DA   354      cmpi.l  #415, playerPositionY               ; Condition for player to touch bottom edge 416(480 - 64)
000014B8  6E00 0004                355      bgt     playerOutOfDisplay
000014BC  4E75                     356      rts
000014BE                           357  
000014BE                           358  ;-------SUBROUTINE-------     
000014BE                           359  playerOutOfDisplay:
000014BE  13FC 0001 0010F825       360      move.b  #1, GAME_LOST
000014C6  4E75                     361      rts   
000014C8                           362  
000014C8                           363      
000014C8                           364  ;-------SUBROUTINE------- 
000014C8                           365  instantiateBall:
000014C8  1039 0010F824            366      move.b  BALL_ISNT_IN_PLAY, d0
000014CE  6700 0014                367      beq     skipInstantiatingBall
000014D2  4EB9 000014E6            368      jsr     initializeBallData                         ; Resets the position of the ball to a position randomly at the borders of the display
000014D8  4EB9 000015FE            369      jsr     setBallVelocity                            ; Based on instantiation, sets the velocity of the ball so that it enters the display  
000014DE  4EB9 0000189A            370      jsr     playBallSound                              ; Subroutine for playing ball sound is near the end of code
000014E4                           371  skipInstantiatingBall:  
000014E4  4E75                     372      rts
000014E6                           373      
000014E6                           374  ;-------SUBROUTINE-------     
000014E6                           375  initializeBallData:
000014E6                           376  ; Resetting variables before instantiating the ball
000014E6  23FC 00000000 0010F7EE   377      move.l  #0, ballVelocityX                           ; Reset the ball's velocity            
000014F0  23FC 00000000 0010F7F2   378      move.l  #0, ballVelocityY
000014FA  13FC 0000 0010F824       379      move.b  #0, BALL_ISNT_IN_PLAY                       ; Reset the boolean so that the ball is in play, ensures only one ball is spawned at a time
00001502                           380  ; Randomly acquire the axis through which the ball must be generated 
00001502  4EB9 00001A2A            381      jsr     getRandomByteIntoD6
00001508  0286 000000FF            382      andi.l  #$000000FF, d6
0000150E  0C86 00000040            383      cmpi.l  #64, d6 
00001514  6D00 0048                384      blt     ballSpawnsFromBot
00001518  0C86 0000007C            385      cmpi.l  #124, d6
0000151E  6D00 0070                386      blt     ballSpawnsFromLeft
00001522  0C86 000000C0            387      cmpi.l  #192, d6
00001528  6D00 00A2                388      blt     ballSpawnsFromRight
0000152C                           389  ; Spawn the ball for various directions
0000152C                           390  ballSpawnsFromTop:
0000152C  13FC 0001 0010F800       391      move.b  #1, ballSpawnDirection
00001534  4EB9 00001A2A            392      jsr     getRandomByteIntoD6
0000153A  0286 000000FF            393      andi.l  #$000000FF, d6                      
00001540  CCFC 024C                394      mulu.w  #588, d6                            ; We want the range of display of 588 pixels, so we multiply by 588
00001544  E086                     395      asr.l   #8, d6                              ; Divide by 256 to get a random number ranging from 0-588
00001546  0686 0000000A            396      add.l   #10, d6                             
0000154C  23C6 0010F7E6            397      move.l  d6, ballPositionX                   ; Ball would be displayed along X in between 10 and 630(598+32) pixels
00001552  23FC FFFFFFE0 0010F7EA   398      move.l  #$FFFFFFE0, ballPositionY           ; Setting position along Y to -32, ensures that the ball is out of display
0000155C  4E75                     399      rts
0000155E                           400  ballSpawnsFromBot:
0000155E  13FC 0002 0010F800       401      move.b  #2, ballSpawnDirection
00001566  4EB9 00001A2A            402      jsr     getRandomByteIntoD6
0000156C  0286 000000FF            403      andi.l  #$000000FF, d6                      
00001572  CCFC 024C                404      mulu.w  #588, d6                            ; We want the range of display of 588 pixels, so we multiply by 588
00001576  E086                     405      asr.l   #8, d6                              ; Divide by 256 to get a random number ranging from 0-588
00001578  0686 0000000A            406      add.l   #10, d6                             
0000157E  23C6 0010F7E6            407      move.l  d6, ballPositionX                   ; Ball would be displayed along X in between 10 and 630(598+32) pixels
00001584  23FC 000001E0 0010F7EA   408      move.l  #480, ballPositionY                 ; Ensures that the ball is out of display initially
0000158E  4E75                     409      rts
00001590                           410  ballSpawnsFromLeft:    
00001590  13FC 0003 0010F800       411      move.b  #3, ballSpawnDirection
00001598  4EB9 00001A2A            412      jsr     getRandomByteIntoD6
0000159E  0286 000000FF            413      andi.l  #$000000FF, d6                      ; To ensure that the random value ranges upto 255.
000015A4  CCFC 01AC                414      mulu.w  #428, d6                            ; We want the range of display of 428 pixels, so we multiply by 428
000015A8  E086                     415      asr.l   #8, d6                              ; Divide by 256 to get a random number ranging from 0-428
000015AA  0686 0000000A            416      add.l   #10, d6                             ; Get a random number ranging from 10-438
000015B0  23C6 0010F7EA            417      move.l  d6, ballPositionY                   ; Ball would be displayed along Y in between 10 and 470(438+32) pixels
000015B6  23FC 00000000 0010F7E6   418      move.l  #0, ballPositionX                   
000015C0  04B9 00000020 0010F7E6   419      sub.l   #32, ballPositionX                  ; Ensures that the ball is out of display initially
000015CA  4E75                     420      rts
000015CC                           421  ballSpawnsFromRight:
000015CC  13FC 0004 0010F800       422      move.b  #4, ballSpawnDirection
000015D4  4EB9 00001A2A            423      jsr     getRandomByteIntoD6
000015DA  0286 000000FF            424      andi.l  #$000000FF, d6                      ; To ensure that the random value ranges upto 255
000015E0  CCFC 01AC                425      mulu.w  #428, d6                            ; We want the range of display of 428 pixels
000015E4  E086                     426      asr.l   #8, d6                              
000015E6  0686 0000000A            427      add.l   #10, d6                             ; Get a random number ranging from 10-438
000015EC  23C6 0010F7EA            428      move.l  d6, ballPositionY                   ; Ball would be displayed along Y in between 10 and 470(438+32) pixels
000015F2  23FC 000002A0 0010F7E6   429      move.l  #672, ballPositionX                 ; 672(640+32) ensures that the ball is out of display initially
000015FC  4E75                     430      rts
000015FE                           431      
000015FE                           432  ;-------SUBROUTINE-------     
000015FE                           433  setBallVelocity:
000015FE                           434  ; Check the spawn direction of the ball, so that velocity may be set as per the spawn position
000015FE  0C39 0001 0010F800       435      cmpi.b  #1, ballSpawnDirection
00001606  6700 0028                436      beq     ballVelocityTop    
0000160A  0C39 0002 0010F800       437      cmpi.b  #2, ballSpawnDirection
00001612  6700 0028                438      beq     ballVelocityBot
00001616  0C39 0003 0010F800       439      cmpi.b  #3, ballSpawnDirection
0000161E  6700 0028                440      beq     ballVelocityLeft
00001622  0C39 0004 0010F800       441      cmpi.b  #4, ballSpawnDirection
0000162A  6700 0028                442      beq     ballVelocityRight
0000162E  4E75                     443      rts
00001630                           444  ; The balls velocity is 5 if spawnned along vertical, else, it is 5.5. For this we'll use fixed point arithmetic such that
00001630                           445  ; 1-bit represents the sign
00001630                           446  ; 27-bits represent the magnitude
00001630                           447  ; 4-bits represent the fraction
00001630                           448  ; Thus, speed is 5 * (16) = 80 or  5.5 * (16) = 88
00001630                           449   
00001630                           450  ballVelocityTop:    
00001630  06B9 00000050 0010F7F2   451      add.l   #80, ballVelocityY
0000163A                           452      ;jsr     deviateBallPathX
0000163A  4E75                     453      rts
0000163C                           454      
0000163C                           455  ballVelocityBot:
0000163C  04B9 00000050 0010F7F2   456      sub.l   #80, ballVelocityY
00001646                           457      ;jsr     deviateBallPathX
00001646  4E75                     458      rts
00001648                           459      
00001648                           460  ballVelocityLeft:
00001648  06B9 00000058 0010F7EE   461      add.l   #88, ballVelocityX
00001652                           462      ;jsr     deviateBallPathY
00001652  4E75                     463      rts    
00001654                           464       
00001654                           465  ballVelocityRight:
00001654  04B9 00000058 0010F7EE   466      sub.l   #88, ballVelocityX
0000165E                           467      ;jsr     deviateBallPathY
0000165E  4E75                     468      rts        
00001660                           469     
00001660                           470  deviateBallPathX:
00001660                           471  ; Load d6 with a random number in the deviation range
00001660  4EB9 00001A2A            472      jsr     getRandomByteIntoD6
00001666  0286 000000FF            473      andi.l  #$000000FF, d6
0000166C  CCFC 0028                474      mulu.w  #DEVIATION_IN_PATH, d6                  
00001670  E08E                     475      lsr.l   #8, d6
00001672                           476  ; Subtracting with half to get the deviation along both directions    
00001672  0486 00000014            477      sub.l   #DEVIATION_IN_PATH>>1, d6               
00001678                           478  ; Add the deviation magnitude along X
00001678  DDB9 0010F7EE            479      add.l   d6, ballVelocityX
0000167E  4E75                     480      rts
00001680                           481   
00001680                           482  deviateBallPathY:
00001680                           483  ; Load d6 with a random number in the deviation range
00001680  4EB9 00001A2A            484      jsr     getRandomByteIntoD6
00001686  0286 000000FF            485      andi.l  #$000000FF, d6
0000168C  CCFC 0028                486      mulu.w  #DEVIATION_IN_PATH, d6                  
00001690  E08E                     487      lsr.l   #8, d6 
00001692                           488  ; Subtracting with half to get the deviation along both directions                                 
00001692  0486 00000014            489      sub.l   #DEVIATION_IN_PATH>>1, d6               
00001698                           490  ; Add the deviation magnitude along Y
00001698  DDB9 0010F7F2            491      add.l   d6, ballVelocityY
0000169E  4E75                     492      rts
000016A0                           493  
000016A0                           494      
000016A0                           495  ;-------SUBROUTINE------- 
000016A0                           496  updateBallOnDisplay:
000016A0  4EB9 000016BA            497      jsr     clearBallFromDisplay                    ; Removes the previously rendered ball from display
000016A6  4EB9 000016F2            498      jsr     updateBallPosition                      ; Updates the position of the ball based on its velocity
000016AC  4EB9 0000171C            499      jsr     checkIfBallIsInPlay                     ; Sets a boolean if there is no ball in play
000016B2  4EB9 000017C6            500      jsr     loadBall                                ; Renders the ball at the updated position
000016B8  4E75                     501      rts    
000016BA                           502     
000016BA                           503  ;-------SUBROUTINE-------     
000016BA                           504  clearBallFromDisplay:
000016BA  2F39 0010F7EA            505      move.l  ballPositionY, -(sp)                    ; Y-Position on output display
000016C0  2F39 0010F7E6            506      move.l  ballPositionX, -(sp)                    ; X-Position on output display
000016C6  2F3C 00000020            507      move.l  #32, -(sp)                              ; Height to display
000016CC  2F3C 00000020            508      move.l  #32, -(sp)                              ; Width to display
000016D2  2F39 0010F7EA            509      move.l  ballPositionY, -(sp)                    ; T-Position in source image
000016D8  2F39 0010F7E6            510      move.l  ballPositionX, -(sp)                    ; X-Position in source image
000016DE  2F3C 00001BC4            511      move.l  #gameBackground, -(sp)                  ; Pointer to game background
000016E4                           512  
000016E4  4EB9 000018B2            513      jsr loadImage                                   ; Call image loading subroutine        
000016EA  DFFC 0000001C            514      add.l   #28, sp                                 ; Reset the stack pointer    
000016F0  4E75                     515      rts
000016F2                           516  
000016F2                           517  ;-------SUBROUTINE-------     
000016F2                           518  updateBallPosition:
000016F2  2039 0010F7EE            519      move.l  ballVelocityX, d0
000016F8  C1F9 0010F7FA            520      muls.w  deltaTime, d0                               ; distance = velocity X time
000016FE  E880                     521      asr.l   #4, d0                                      ; Since the velocity term has 4 fractional bits, we divide by 16
00001700  D1B9 0010F7E6            522      add.l   d0, ballPositionX
00001706  2039 0010F7F2            523      move.l  ballVelocityY, d0
0000170C  C1F9 0010F7FA            524      muls.w  deltaTime, d0                               
00001712  E880                     525      asr.l   #4, d0                                      
00001714  D1B9 0010F7EA            526      add.l   d0, ballPositionY
0000171A  4E75                     527      rts
0000171C                           528      
0000171C                           529  ;-------SUBROUTINE-------     
0000171C                           530  checkIfBallIsInPlay:    
0000171C                           531  ; Check if updating ball's position took it out of play area
0000171C  0C39 0001 0010F800       532      cmpi.b  #1, ballSpawnDirection
00001724  6700 0026                533      beq     ballOutForTopSpawn                      ; If ball spawned from top, preform check for ball exiting from bottom
00001728  0C39 0002 0010F800       534      cmpi.b  #2, ballSpawnDirection
00001730  6700 0038                535      beq     ballOutForBotSpawn                      ; If ball spawned from bot, preform check for ball exiting from top
00001734  0C39 0003 0010F800       536      cmpi.b  #3, ballSpawnDirection
0000173C  6700 004A                537      beq     ballOutForLeftSpawn                     ; If ball spawned from left, preform check for ball exiting from right
00001740  0C39 0004 0010F800       538      cmpi.b  #4, ballSpawnDirection
00001748  6700 005C                539      beq     ballOutForRightSpawn                    ; If ball spawned from right, preform check for ball exiting from left
0000174C                           540       
0000174C                           541  ballOutForTopSpawn:    
0000174C  0CB9 000001E0 0010F7EA   542      cmpi.l  #480, ballPositionY
00001756  6D00 006C                543      blt     ContinuePlayWithCurrentBall             ; If y > 480, ball is out of play
0000175A  13FC 0001 0010F824       544      move.b  #1, BALL_ISNT_IN_PLAY                   ; Set boolean for ball out of play
00001762  52B9 0010F7F6            545      add.l   #1, score                               ; Increment the score
00001768  4E75                     546      rts
0000176A                           547  ballOutForBotSpawn:
0000176A  0CB9 FFFFFFE0 0010F7EA   548      cmpi.l  #$FFFFFFE0, ballPositionY
00001774  6E00 004E                549      bgt     ContinuePlayWithCurrentBall             ; If y < -32, ball is out of play
00001778  13FC 0001 0010F824       550      move.b  #1, BALL_ISNT_IN_PLAY                   ; Set boolean for ball out of play
00001780  52B9 0010F7F6            551      add.l   #1, score                               ; Increment the score
00001786  4E75                     552      rts
00001788                           553  ballOutForLeftSpawn:
00001788  0CB9 00000280 0010F7E6   554      cmpi.l  #640, ballPositionX
00001792  6D00 0030                555      blt     ContinuePlayWithCurrentBall             ; If x > 640, ball is out of play
00001796  13FC 0001 0010F824       556      move.b  #1, BALL_ISNT_IN_PLAY                   ; Set boolean for ball out of play
0000179E  52B9 0010F7F6            557      add.l   #1, score                               ; Increment the score
000017A4  4E75                     558      rts
000017A6                           559  ballOutForRightSpawn:
000017A6  0CB9 FFFFFFE0 0010F7E6   560      cmpi.l  #$FFFFFFE0, ballPositionX               
000017B0  6E00 0012                561      bgt     ContinuePlayWithCurrentBall             ; If x < -32, ball is out of play
000017B4  13FC 0001 0010F824       562      move.b  #1, BALL_ISNT_IN_PLAY                   ; Set boolean for ball out of play
000017BC  52B9 0010F7F6            563      add.l   #1, score                               ; Increment the score
000017C2  4E75                     564      rts
000017C4                           565  continuePlayWithCurrentBall:    
000017C4  4E75                     566      rts  
000017C6                           567  
000017C6                           568  ;-------SUBROUTINE-------   
000017C6                           569  loadBall:
000017C6  2F39 0010F7EA            570      move.l  ballPositionY, -(sp)                    ; Y-Position on output display
000017CC  2F39 0010F7E6            571      move.l  ballPositionX, -(sp)                    ; X-Position on output display
000017D2  2F3C 00000020            572      move.l  #32, -(sp)                              ; Height to display
000017D8  2F3C 00000020            573      move.l  #32, -(sp)                              ; Width to display
000017DE  2F3C 00000000            574      move.l  #0, -(sp)                               ; Y-Position in source image
000017E4  2F3C 00000000            575      move.l  #0, -(sp)                               ; X-Position in source image
000017EA  2F3C 00078730            576      move.l  #ballSprite, -(sp)                      ; Pointer to ball sprite
000017F0                           577  
000017F0  4EB9 000018B2            578      jsr loadImage                                   ; Call image loading subroutine        
000017F6  DFFC 0000001C            579      add.l   #28, sp                                 ; Reset the stack pointer    
000017FC  4E75                     580      rts    
000017FE                           581  
000017FE                           582  ;-------SUBROUTINE------- 
000017FE                           583  checkForCollision:
000017FE                           584  ; Load the coordinates of the top left corners of both the sprites in d0...d4
000017FE  2039 0010F7D6            585      move.l  playerPositionX, d0
00001804  2239 0010F7DA            586      move.l  playerPositionY, d1
0000180A  2439 0010F7E6            587      move.l  ballPositionX, d2
00001810  2639 0010F7EA            588      move.l  ballPositionY, d3
00001816                           589  ; Estimate the centers of both the sprites
00001816  0680 00000020            590      add.l   #32, d0                                 ; There are 4 pixels to the left of player and the radius of the player is 28 pixels, thus 32 pixels is the offset along X
0000181C  0681 00000024            591      add.l   #36, d1                                 ; There are approximately 8 pixels above the player and the radius of the player is 28 pixels, thus 36 pixels is the offset along Y      
00001822  0682 00000010            592      add.l   #16, d2                                 ; The radius of the ball is 16 pixels, thus the offset along X for ball is 16
00001828  0683 00000010            593      add.l   #16, d3                                 ; The radius of the ball is 16 pixels, thus the offset along Y for ball is 16
0000182E                           594  ; Estimate the realtive positions of the two sprites, i.e. (x1-x2) and (y1-y2)
0000182E  9480                     595      sub.l   d0,d2                                   ; d2 = Xball - Xplayer
00001830  9681                     596      sub.l   d1,d3                                   ; d3 = YBall - YPlayer
00001832                           597  ; Perform a check if collision testing is required
00001832  0C82 00000000            598      cmpi.l  #0, d2
00001838  6E00 0004                599      bgt     xDifferenceIsPositive                   ; If the difference isn't positive, negate the number
0000183C  4442                     600      neg     d2                                      
0000183E                           601  xDifferenceIsPositive:
0000183E  0C83 00000000            602      cmpi.l  #0, d3                                  
00001844  6E00 0004                603      bgt     yDifferenceIsPositive                   ; If the difference isn't positive, negate the number
00001848  4443                     604      neg     d3
0000184A                           605  yDifferenceIsPositive:
0000184A                           606  ; The sum of the radii is 44 (16 + 28), if the distance along an axis is more than 44, it means that there won't be any collision
0000184A  0C82 0000002C            607      cmpi.l  #44, d2
00001850  6E00 0024                608      bgt     noCollisionCheckRequired
00001854  0C83 0000002C            609      cmpi.l  #44, d3
0000185A  6E00 001A                610      bgt     noCollisionCheckRequired
0000185E                           611  ; Perform check for collision
0000185E                           612  ; The distance between the two for collision must meet the condition [(Xball - Xplayer)^2 + (YBall - YPlayer)^2] < (r1 + r2)^2
0000185E  C5C2                     613      muls.w  d2, d2
00001860  C7C3                     614      muls.w  d3, d3
00001862  D682                     615      add.l   d2, d3
00001864  742C                     616      move.l  #44, d2
00001866  C5C2                     617      muls.w  d2, d2
00001868  B682                     618      cmp.l   d2, d3
0000186A  6E00 000A                619      bgt     noCollisionCheckRequired                ; If there is no collision, don't set the boolean for lose condition
0000186E  13FC 0001 0010F825       620      move.b  #1, GAME_LOST
00001876                           621  noCollisionCheckRequired:   
00001876  4E75                     622      rts    
00001878                           623      
00001878                           624  ;-------SUBROUTINE------- 
00001878                           625  ; Once players movement for a jump is complelte, new input is enabled by calling this subroutine
00001878                           626  resetInputBooleans:
00001878  13FC 0000 0010F820       627      move.b  #0, UP_INPUT
00001880  13FC 0000 0010F821       628      move.b  #0, DOWN_INPUT
00001888  13FC 0000 0010F822       629      move.b  #0, LEFT_INPUT
00001890  13FC 0000 0010F823       630      move.b  #0, RIGHT_INPUT       
00001898  4E75                     631      rts
0000189A                           632  ;-------SUBROUTINE------- 
0000189A                           633  playBallSound:
0000189A  227C 0010F801            634      move.l  #ballSound, a1
000018A0  7049                     635      move.l  #PLAY_SOUND_TRAP_CODE, d0
000018A2  4E4F                     636      trap    #15
000018A4  4E75                     637      rts
000018A6                           638      
000018A6                           639  ;-------SUBROUTINE-------     
000018A6                           640  playJumpSound:
000018A6  227C 0010F816            641      move.l  #jumpSound, a1
000018AC  7049                     642      move.l  #PLAY_SOUND_TRAP_CODE, d0
000018AE  4E4F                     643      trap    #15
000018B0  4E75                     644      rts    
000018B2                           645      
000018B2                           646      INCLUDE "bmpLoader.x68"                         ; A subroutine for rendering sprites on display
000018B2                           647  ;********************************************************************
000018B2                           648  ; A SUBROUTINE to display a chunk of an image at a specific position
000018B2                           649  
000018B2  =00000050                650  PEN_COLOR_TRAP_CODE                     EQU     80
000018B2  =00000052                651  DRAW_PIXEL_TRAP_CODE                    EQU     82
000018B2                           652  IMAGE_USED_REG                          REG     D0/D1/D2/D4/D5/D6/D7/A1/A2/A6     
000018B2                           653  
000018B2  =00000004                654  SOURCE_IMAGE_LOC_S      EQU     4
000018B2                           655  ; X position of the top left corner of the chunk of image
000018B2  =00000008                656  X_SOURCE_S              EQU     8
000018B2                           657  ; Y position of the top left corner of the chunk of image
000018B2  =0000000C                658  Y_SOURCE_S              EQU     12
000018B2                           659  ; The width of chunk to be copied 
000018B2  =00000010                660  WIDTH_S                 EQU     16
000018B2                           661  ; The height of chunk to be copied
000018B2  =00000014                662  HEIGHT_S                EQU     20
000018B2                           663  ; The X position on display where the image should be copied  
000018B2  =00000018                664  X_DESTINATION_S         EQU     24
000018B2                           665  ; The Y position on display where the image should be copied
000018B2  =0000001C                666  Y_DESTINATION_S         EQU     28
000018B2                           667  ; Push the pointer to the image address in memory
000018B2                           668  ; Push above on stack in reverse order
000018B2                           669  
000018B2                           670  
000018B2                           671  loadImage:
000018B2                           672  ; Save the current contents of registers
000018B2  48E7 EF62                673          movem.l IMAGE_USED_REG, -(sp)
000018B6  DFFC 00000028            674          add.l  #40, sp                                          ; Offset to access the values on the stack which were pushed for the subroutine
000018BC                           675  ; Load the address of the pixel table location in pixelArray
000018BC  2C6F 0004                676          move.l  SOURCE_IMAGE_LOC_S(sp), a6        
000018C0  DDFC 0000000A            677          add.l   #10, a6                                         ; a6 now points to location with pixel array offset     
000018C6  2016                     678          move.l  (a6), d0                                        ; Load the value of pixel array offset to register
000018C8  4EB9 000019FE            679          jsr     littleToBig                                     ; d0 now contains the offset in big endian format
000018CE  2A2F 0004                680          move.l  SOURCE_IMAGE_LOC_S(sp), d5
000018D2  D085                     681          add.l   d5, d0                                          ; Adding offset to location of the image gives location of pixel table
000018D4  23C0 00001A06            682          move.l  d0, pixelArray                                  ; Save the location of pixel table
000018DA                           683  ; Load the address of the color table location in colorArray
000018DA  226F 0004                684          move.l  SOURCE_IMAGE_LOC_S(sp), a1        
000018DE  D3FC 0000000E            685          add.l   #14, a1                                         ; a1 now points to location with color table offset from a1
000018E4  2011                     686          move.l  (a1), d0                                        ; Load the value of color table offset(from a1) to register
000018E6  4EB9 000019FE            687          jsr     littleToBig                                     ; Convert the offset to the color table to big endian
000018EC  D089                     688          add.l   a1, d0                                          ; Calculate the position of the color table in memory
000018EE  23C0 00001A0A            689          move.l  d0, colorArray                                  ; Save the location of color table
000018F4                           690  ; Load source image width and height
000018F4  226F 0004                691          move.l  SOURCE_IMAGE_LOC_S(sp), a1
000018F8  D3FC 00000012            692          add.l   #18, a1                                         ; Offset for width in header
000018FE  2011                     693          move.l  (a1), d0
00001900  4EB9 000019FE            694          jsr     littleToBig
00001906  23C0 00001A0E            695          move.l  d0, imageWidth                                  ; Save source image width
0000190C                           696             
0000190C  226F 0004                697          move.l  SOURCE_IMAGE_LOC_S(sp), a1
00001910  D3FC 00000016            698          add.l   #22, a1                                         ; Offset for height in header
00001916  2011                     699          move.l  (a1), d0
00001918  4EB9 000019FE            700          jsr     littleToBig
0000191E  23C0 00001A12            701          move.l  d0, imageHeight                                 ; Save source image height 
00001924                           702  ; Estimate the number of bytes used for padding
00001924  2039 00001A0E            703          move.l  imageWidth, d0
0000192A  80FC 0004                704          divu.w  #4, d0  
0000192E  4840                     705          swap.w  d0                                              ; Move the remainder to lower word
00001930  4281                     706          clr.l   d1
00001932  3200                     707          move.w  d0, d1                                          ; Move the remainder to cleared register
00001934  7004                     708          move.l  #4, d0
00001936  9081                     709          sub.l   d1, d0                                          ; Estimate the padding count, i.e the number of extra bytes in each row of the image
00001938  23C0 00001A16            710          move.l  d0, paddingCount
0000193E                           711          
0000193E  0CB9 00000004 00001A16   712          cmpi.l  #4, paddingCount                                ; In case the remainder is 0, i.e. the factor is 4, there is no padding
00001948  6700 00A6                713          beq     resetPadding                                    ; Set the padding count to 0
0000194C                           714  afterPadding:
0000194C                           715  ; Print the color on display
0000194C  2C2F 0010                716          move.l  WIDTH_S(sp) , d6
00001950  2E2F 0014                717          move.l  HEIGHT_S(sp), d7
00001954                           718          
00001954                           719  ; Accout for pixels to skip before printing
00001954  2279 00001A06            720          move.l  pixelArray, a1                                  ; a1 will be used to refer to pixel table in display loop
0000195A  2039 00001A12            721          move.l  imageHeight, d0
00001960  90AF 0014                722          sub.l   HEIGHT_S(sp), d0
00001964  90AF 000C                723          sub.l   Y_SOURCE_S(sp), d0                              ; d0 contains the number of rows to be skipped from the bottom of the image while displaying
00001968  2239 00001A0E            724          move.l  imageWidth, d1
0000196E  D2B9 00001A16            725          add.l   paddingCount, d1                                ; d1 contains the number of pixels to be skipped for each row of pixels 
00001974  C0C1                     726          mulu.w  d1, d0                                          ; d0 contains all the pixels skipped in rows below the chunk
00001976                           727          
00001976  D0AF 0008                728          add.l   X_SOURCE_S(sp), d0                              ; Account for the skipped pixels along the first row which will be printed 
0000197A  D3C0                     729          add.l  d0, a1                                           ; a1 contains the effective location of the first pixel to print        
0000197C                           730          
0000197C  2479 00001A0A            731          move.l  colorArray, a2                                  ; a2 will be used to refer to color table in display loop       
00001982                           732  ; Load postions from where drawing will start
00001982  222F 0018                733          move.l  X_DESTINATION_S(sp), d1         
00001986  242F 001C                734          move.l  Y_DESTINATION_S(sp), d2         
0000198A  D4AF 0014                735          add.l  HEIGHT_S(sp), d2                                 ; Since pixel table is has bottom most row first, we print from bottom row, left to right
0000198E                           736  
0000198E                           737  printingOnDisplay:
0000198E                           738  ; Change pen color
0000198E  2801                     739          move.l  d1, d4                                          ; Save the x position for next pixel to display at d4
00001990  4241                     740          clr     d1
00001992  1219                     741          move.b  (a1)+, d1                                       ; Move the value in pixel table to d0
00001994  C2FC 0004                742          mulu    #4, d1                                          ; Each value in pixel table takes 4 bytes, so calcuate the relative position using the index value 
00001998  D2B9 00001A0A            743          add.l   colorArray, d1                                  ; d1 contains the location with color information
0000199E  2441                     744          move.l  d1, a2          
000019A0  2212                     745          move.l  (a2), d1                                        ; Load color value for pixel into d1
000019A2  E099                     746          ror.l   #8, d1                                          ; Rotate the contents of color to get it in the 0x00BBGGRR format
000019A4                           747  ; Check for pixel that should be skipped       
000019A4  0C81 00FFFFFF            748          cmpi.l   #$00FFFFFF, d1
000019AA  6700 000C                749          beq     pixelSkipped                                    ; If pixel is white, skip drawing of pixel
000019AE                           750          
000019AE  7050                     751          move.l  #PEN_COLOR_TRAP_CODE, d0
000019B0  4E4F                     752          trap    #15                                             ; Set pen color
000019B2                           753          
000019B2                           754  ; Print on display
000019B2  2204                     755          move.l  d4, d1                                          ; Retrieve x postion to display pixel
000019B4  7052                     756          move.l  #DRAW_PIXEL_TRAP_CODE, d0
000019B6  4E4F                     757          trap    #15                                             ; Draw a pixel
000019B8                           758  pixelSkipped:
000019B8  2204                     759          move.l  d4, d1       
000019BA  5281                     760          addi.l  #1, d1                                          ; Increment the position along the width to display pixels
000019BC                           761          
000019BC                           762          
000019BC  2C2F 0010                763          move.l  WIDTH_S(sp), d6
000019C0  DCAF 0018                764          add.l   X_DESTINATION_S(sp), d6                         ; End of the displayed row is at X_DESTINATION + WIDTH
000019C4                           765   
000019C4                           766          
000019C4  BC81                     767          cmp.l   d1, d6                                          ; Check if the entire row has been displayed
000019C6  66C6                     768          bne     printingOnDisplay                               
000019C8                           769           
000019C8  D3F9 00001A0E            770          add.l   imageWidth, a1                                  
000019CE  93EF 0010                771          sub.l   WIDTH_S(sp), a1                                 ; Skip pixels as much as the difference between source image width and the width of the chunk
000019D2  D3F9 00001A16            772          add.l   paddingCount, a1                                ; Account for padding in current row and skip those padding bytes
000019D8                           773  
000019D8  222F 0018                774          move.l  X_DESTINATION_S(sp), d1                         ; Reset the row for displaying at the left most position
000019DC  5382                     775          subi.l  #1, d2                                          ; Decrement the position along the vertical to display 
000019DE  B4AF 001C                776          cmp.l   Y_DESTINATION_S(sp), d2                         ; Check if all the rows have been printed
000019E2  66AA                     777          bne     printingOnDisplay
000019E4                           778          
000019E4  9FFC 00000028            779          sub.l  #40, sp
000019EA  4CDF 46F7                780          movem.l (sp)+, IMAGE_USED_REG
000019EE                           781                 
000019EE  4E75                     782          rts   
000019F0                           783  ; Used to reset the padding count in case the reaminder from division is 0
000019F0                           784  resetPadding:
000019F0  23FC 00000000 00001A16   785          move.l  #0, paddingCount
000019FA  6000 FF50                786          bra     afterPadding
000019FE                           787       
000019FE                           788  ; A subroutine to convert the long word at d0 from little endian to big endian
000019FE                           789  littleToBig:
000019FE  E058                     790          ror.w   #8, d0                                          ; Swap the upper two bytes
00001A00  4840                     791          swap.w  d0                                              ; Swap the upper and lower words
00001A02  E058                     792          ror.w   #8, d0                                          ; Swap the lower two bytes
00001A04  4E75                     793          rts
00001A06                           794  
00001A06                           795  
00001A06                           796  ; Stores the address from where the pixel table starts   
00001A06                           797  pixelArray:
00001A06                           798          ds.l    1
00001A0A                           799  ; Stores the address from where the color table starts        
00001A0A                           800  colorArray:
00001A0A                           801          ds.l    1
00001A0E                           802  ; Stores the width of the source image being rendered
00001A0E                           803  imageWidth:
00001A0E                           804          ds.l    1
00001A12                           805  ; Stores the height of the source image being rendered        
00001A12                           806  imageHeight:
00001A12                           807          ds.l    1
00001A16                           808  ; Stores the number of bytes used for padding the pixel array        
00001A16                           809  paddingCount:
00001A16                           810          ds.l    1
00001A1A                           811  
00001A1A                           812  ;*********************************************************************
00001A1A                           813  
00001A1A                           814  
00001A1A                           815  
00001A1A                           816  
00001A1A                           817  -------------------- end include --------------------
00001A1A                           818      INCLUDE "randomizationFunctions.x68"            ; A subroutine for random number generation
00001A1A                           819  ;********************************************************************
00001A1A                           820  ; Subroutines for a random number generator which uses seedRandomNumber
00001A1A                           821  ; to seed the random number generator which is getRandomByteIntoD6 below
00001A1A                           822  seedRandomNumber:
00001A1A  4286                     823          clr.l   d6
00001A1C  103C 0008                824          move.b  #TIME_SINCE_MIDNIGHT_TRAP_CODE,d0
00001A20  4E4F                     825          TRAP    #15
00001A22                           826          
00001A22  23C1 00001A4A            827          move.l  d1,RANDOMVAL
00001A28  4E75                     828          rts
00001A2A                           829  
00001A2A                           830  getRandomByteIntoD6: 
00001A2A  2039 00001A4A            831          move.l  RANDOMVAL,d0
00001A30  72AF                     832          moveq   #$AF-$100,d1
00001A32  7412                     833          moveq   #18,d2
00001A34                           834  Ninc0:  
00001A34  D080                     835          add.l   d0,d0
00001A36  6400 0004                836          bcc     Ninc1
00001A3A  B300                     837          eor.b   d1,d0
00001A3C                           838  Ninc1:
00001A3C  51CA FFF6                839          dbf     d2,Ninc0
00001A40  23C0 00001A4A            840          move.l  d0,RANDOMVAL
00001A46  2C00                     841          move.l  d0,d6
00001A48  4E75                     842          rts
00001A4A                           843      
00001A4A                           844  RANDOMVAL       ds.l    1
00001A4E                           845  
00001A4E                           846  ;********************************************************************
00001A4E                           847  
00001A4E                           848  
00001A4E                           849  -------------------- end include --------------------
00001A4E                           850      INCLUDE "ledDisplaySubroutine.x68"
00001A4E                           851  ;********************************************************************
00001A4E                           852  ; A subroutine which takes a number as an input and displays it
00001A4E                           853  ; using three 7-segment LEDs at a specific position given by user
00001A4E                           854  
00001A4E  =00000050                855  PEN_COLOR_TRAP_CODE         EQU     80
00001A4E  =0000005D                856  PEN_WIDTH_TRAP_CODE         EQU     93
00001A4E  =00000054                857  DRAW_LINE_TRAP_CODE         EQU     84
00001A4E                           858  
00001A4E  =00C0C0C0                859  COLOR                       EQU     $00C0C0C0
00001A4E  =00000005                860  PEN_WIDTH                   EQU     5           ; Don't change pen width
00001A4E  =0000003C                861  DISPLACEMENT_BETWEEN_LED    EQU     60
00001A4E                           862  
00001A4E  =00000164                863  VALUE_FOR_SUBROUTINE        EQU     356
00001A4E  =00000000                864  TOP_LEFT_X                  EQU     0
00001A4E  =00000190                865  TOP_LEFT_Y                  EQU     400
00001A4E                           866  
00001A4E  =00000004                867  VALUE_FOR_SUBROUTINE_S      EQU     4
00001A4E  =00000008                868  TOP_LEFT_X_S                EQU     8
00001A4E  =0000000C                869  TOP_LEFT_Y_S                EQU     12
00001A4E                           870  
00001A4E                           871  LED_USED_REG                REG     D0/D1/D2/D3/D4/D5/D6/A0/A1
00001A4E                           872  
00001A4E                           873  ; Subroutine to be called to display the entire number
00001A4E                           874  displayNumberOnLEDs:
00001A4E                           875  ; Save the registers which will be used
00001A4E  48E7 FEC0                876      movem.l LED_USED_REG, -(sp)
00001A52  DFFC 00000024            877      add.l   #36, sp
00001A58                           878  ; Set the pen color to white
00001A58  7050                     879      move.l  #PEN_COLOR_TRAP_CODE, d0
00001A5A  223C 00C0C0C0            880      move.l  #COLOR, d1
00001A60  4E4F                     881      trap    #15
00001A62                           882  ; Set pen width to 5 pixels    
00001A62  705D                     883      move.l  #PEN_WIDTH_TRAP_CODE, d0
00001A64  7205                     884      move.l  #PEN_WIDTH, d1
00001A66  4E4F                     885      trap    #15
00001A68                           886  ; Save the number to display in memory    
00001A68  202F 0004                887      move.l  VALUE_FOR_SUBROUTINE_S(sp), d0
00001A6C  23C0 00001BBC            888      move.l  d0, tempData
00001A72                           889  ; Check the number of digits in the number
00001A72  0C80 000003E7            890      cmpi.l  #999, d0
00001A78  6E00 009A                891      bgt     scoreNotDisplayed
00001A7C  0C80 00000063            892      cmpi.l  #99, d0
00001A82  6E00 0028                893      bgt     tripleDigitScore
00001A86  0C80 00000009            894      cmpi.l  #9, d0
00001A8C  6E00 0010                895      bgt     doubleDigitScore
00001A90                           896  ; Save the number of digits in memory
00001A90                           897  singleDigitScore:
00001A90  23FC 00000001 00001BC0   898      move.l  #1, lengthOfNumber
00001A9A  6000 001E                899      bra     displayNumber
00001A9E                           900  doubleDigitScore:
00001A9E  23FC 00000002 00001BC0   901      move.l  #2, lengthOfNumber
00001AA8  6000 0010                902      bra     displayNumber
00001AAC                           903  tripleDigitScore:    
00001AAC  23FC 00000003 00001BC0   904      move.l  #3, lengthOfNumber
00001AB6  6000 0002                905      bra     displayNumber
00001ABA                           906  ; Conditions for LED displaying loop    
00001ABA                           907  displayNumber:
00001ABA  4246                     908      clr     d6
00001ABC  2E39 00001BC0            909      move.l  lengthOfNumber, d7
00001AC2                           910  ; A loop which performs displaying of one digit of the number at a time, starting from the
00001AC2                           911  ; right most place value    
00001AC2                           912  displayLoop:
00001AC2  2039 00001BBC            913      move.l  tempData, d0                    ; Load the number to display into d0
00001AC8  2C00                     914      move.l  d0, d6
00001ACA  0C87 00000001            915      cmpi.l  #1, d7
00001AD0  6700 001E                916      beq     dontDivide                      ; Check if the digit to display is in ones place, i.e. right most place value
00001AD4  80FC 000A                917      divu    #10, d0
00001AD8  2C00                     918      move.l  d0, d6    
00001ADA  0280 0000FFFF            919      andi.l  #$0000FFFF, d0                  ; d0 = Quotient
00001AE0  23C0 00001BBC            920      move.l  d0, tempData
00001AE6  0286 FFFF0000            921      andi.l  #$FFFF0000, d6                  ; Contains remainder term
00001AEC  E09E                     922      ror.l   #8, d6
00001AEE  E09E                     923      ror.l   #8, d6                          ; d6 = Remainder
00001AF0                           924  dontDivide: 
00001AF0  7A3C                     925      move.l  #DISPLACEMENT_BETWEEN_LED, d5
00001AF2  2807                     926      move.l  d7, d4
00001AF4  5384                     927      sub.l   #1, d4
00001AF6  CAC4                     928      mulu    d4, d5                          ; Offset along the X from the top left corner of the LED display (X Offset = Number of digits before the digit (d4) * Pixel width for each digit (d5))
00001AF8  DAAF 0008                929      add.l   TOP_LEFT_X_S(sp), d5            ; Top left corner of where the LED should be displayed
00001AFC  2F2F 000C                930      move.l  TOP_LEFT_Y_S(sp), -(sp)         ; Top left Y position for particular digit
00001B00  2F05                     931      move.l  d5, -(sp)                       ; Top left X position for particular digit
00001B02  2F06                     932      move.l  d6, -(sp)                       ; Digit to display pushed on stack
00001B04                           933      
00001B04  4EB9 00001B20            934      jsr displayValueOnLEDs
00001B0A  DFFC 0000000C            935      add.l   #12, sp
00001B10  5387                     936      sub.l   #1, d7                          ; Number of digits left to display
00001B12  66AE                     937      bne     displayLoop                     
00001B14                           938  scoreNotDisplayed:    
00001B14  9FFC 00000024            939      sub.l   #36, sp
00001B1A  4CDF 037F                940      movem.l (sp)+, LED_USED_REG
00001B1E  4E75                     941      rts
00001B20                           942      
00001B20                           943  ; SUBROUTINE for display a number
00001B20                           944  displayValueOnLEDs:
00001B20  48E7 FEC0                945      movem.l LED_USED_REG, -(sp)             ; Save the contents of registers which would be used by subroutine
00001B24  DFFC 00000024            946      add.l   #36, sp                         ; Incrementing sp to access the user input easily
00001B2A                           947      
00001B2A  202F 0004                948      move.l  VALUE_FOR_SUBROUTINE_S(sp), d0  ; Load the value in d0
00001B2E  207C 00001B96            949      move.l  #digitTable, a0
00001B34  4281                     950      clr.l   d1
00001B36  227C 00001BA0            951      move.l  #ledDisplayOffsetTable, a1
00001B3C  1230 0000                952      move.b  (a0, d0), d1                    ; Acquire the mask byte for the number in d0 
00001B40  2A01                     953      move.l  d1, d5                          ; d5 will store the original byte and it will be rotated to access mask bits
00001B42  2C3C 00001BA0            954      move.l  #ledDisplayOffsetTable, d6
00001B48  0686 0000001C            955      add.l   #28, d6                         ; d6 contains the address for last value of led offset table
00001B4E                           956          
00001B4E                           957  displayLEDs:
00001B4E                           958  ; Check the mask bit
00001B4E  2405                     959      move.l  d5, d2                          ; Move the shifted byte to d2 
00001B50  0282 00000001            960      andi.l  #1, d2
00001B56  6700 002A                961      beq     displayingLEDNotRequired        ; Continue if the mask bit is 1
00001B5A                           962  ; Load the (xi, yi) and (xf, yf) for display into d1, d2, d3, d4
00001B5A  4241                     963      clr     d1
00001B5C  4242                     964      clr     d2
00001B5E  4243                     965      clr     d3
00001B60  4244                     966      clr     d4
00001B62                           967  
00001B62  1219                     968      move.b  (a1)+, d1
00001B64  D2AF 0008                969      add.l   TOP_LEFT_X_S(sp), d1            ; Estimate the initial position for display from top left X
00001B68  1419                     970      move.b  (a1)+, d2
00001B6A  D4AF 000C                971      add.l   TOP_LEFT_Y_S(sp), d2            ; Estimate the initial position for display from top left Y
00001B6E  1619                     972      move.b  (a1)+, d3
00001B70  D6AF 0008                973      add.l   TOP_LEFT_X_S(sp), d3            ; Estimate the final position for display from top left Y
00001B74  1819                     974      move.b  (a1)+, d4
00001B76  D8AF 000C                975      add.l   TOP_LEFT_Y_S(sp), d4            ; Estimate the final position for display from top left Y
00001B7A                           976  ; Draw the line   
00001B7A  7054                     977      move.l  #DRAW_LINE_TRAP_CODE, d0
00001B7C  4E4F                     978      trap    #15
00001B7E  6000 0004                979      bra     skipIncreasingAddress
00001B82                           980  displayingLEDNotRequired:    
00001B82  5889                     981      add.l   #4, a1
00001B84                           982  skipIncreasingAddress:    
00001B84  E28D                     983      lsr.l   #1, d5                          ; Shifting the byte to access next mask bit
00001B86  B3C6                     984      cmp.l   d6, a1
00001B88  6DC4                     985      blt     displayLEDs                     ; If the entire offset table hasn't been traversed, continue displaying LEDs
00001B8A                           986      
00001B8A  9FFC 00000024            987      sub.l   #36, sp
00001B90  4CDF 037F                988      movem.l (sp)+, LED_USED_REG
00001B94  4E75                     989      rts    
00001B96                           990  
00001B96                           991  ; Mapping for numbers to be displayed. Each number has a 7 bit representation.
00001B96                           992  ; A bit is 1 for corresponding LED to be on, or 0 for corresponding LED to be off.
00001B96                           993  ; A byte is representing the following: x(don't care) | g | f | e | d | c | b | a
00001B96                           994  digitTable:
00001B96= 3F 06 5B 4F 66 6D ...    995      dc.b    $3F, $06, $5B, $4F, $66, $6D, $7D, $07, $7F, $6F
00001BA0                           996      
00001BA0                           997  ; Offsets for displaying LEDs for the seven segment display    
00001BA0                           998  ledDisplayOffsetTable:
00001BA0= 0D 08 2E 08              999      dc.b    13, 08, 46, 08          ; (xi, yi), (xf, yf) for LED A, i.e. the offsets for displaying LED A
00001BA4= 34 0D 34 22             1000      dc.b    52, 13, 52, 34          ; (xi, yi), (xf, yf) for LED B
00001BA8= 34 2E 34 42             1001      dc.b    52, 46, 52, 66          ; (xi, yi), (xf, yf) for LED C
00001BAC= 0D 49 2E 49             1002      dc.b    13, 73, 46, 73          ; (xi, yi), (xf, yf) for LED D
00001BB0= 07 2E 07 42             1003      dc.b    07, 46, 07, 66          ; (xi, yi), (xf, yf) for LED E
00001BB4= 07 0D 07 22             1004      dc.b    07, 13, 07, 34          ; (xi, yi), (xf, yf) for LED F
00001BB8= 0D 29 2E 29             1005      dc.b    13, 41, 46, 41          ; (xi, yi), (xf, yf) for LED G
00001BBC                          1006  ; Temporary data used to store quotient from division operations    
00001BBC                          1007  tempData:    
00001BBC                          1008      ds.l    1
00001BC0                          1009  ; Stores the number of digits in a number to be displayed    
00001BC0                          1010  lengthOfNumber:
00001BC0                          1011      ds.l    1    
00001BC4                          1012  ;********************************************************************
00001BC4                          1013  
00001BC4                          1014  
00001BC4                          1015  
00001BC4                          1016  
00001BC4                          1017  
00001BC4                          1018  
00001BC4                          1019  
00001BC4                          1020  
00001BC4                          1021  
00001BC4                          1022  
00001BC4                          1023  
00001BC4                          1024  
00001BC4                          1025  
00001BC4                          1026  
00001BC4                          1027  
00001BC4                          1028  
00001BC4                          1029  
00001BC4                          1030  
00001BC4                          1031  
00001BC4                          1032  
00001BC4                          1033  
00001BC4                          1034  
00001BC4                          1035  
00001BC4                          1036  
00001BC4                          1037  -------------------- end include --------------------
00001BC4                          1038      
00001BC4                          1039  gameBackground:
00001BC4                          1040      INCBIN "grassBackground.bmp"
000772FA                          1041  playerSprite:
000772FA                          1042      INCBIN  "doge64x64.bmp"    
00078730                          1043  ballSprite:
00078730                          1044      INCBIN  "ball32x32.bmp"  
00078F66                          1045  endScreen:
00078F66                          1046      INCBIN  "endGameScreen.bmp"  
000C439C                          1047  startScreen:
000C439C                          1048      INCBIN  "startGameScreen.bmp"
0010F7D2                          1049   
0010F7D2                          1050  ; Saves the input from the user for future use
0010F7D2                          1051  playerInput:
0010F7D2                          1052      ds.l    1
0010F7D6                          1053  ; Variables to store the top left corner from where the player is displayed
0010F7D6                          1054  playerPositionX:
0010F7D6                          1055      ds.l    1
0010F7DA                          1056  playerPositionY:
0010F7DA                          1057      ds.l    1    
0010F7DE                          1058  ; Variables to store the velocity of the player
0010F7DE                          1059  playerVelocityX:
0010F7DE                          1060      ds.l    1
0010F7E2                          1061  playerVelocityY:
0010F7E2                          1062      ds.l    1
0010F7E6                          1063  ; Variables to store the top left corner from where the ball is displayed  
0010F7E6                          1064  ballPositionX:
0010F7E6                          1065      ds.l    1
0010F7EA                          1066  ballPositionY:
0010F7EA                          1067      ds.l    1    
0010F7EE                          1068  ; Variables to store the velocity of the ball    
0010F7EE                          1069  ballVelocityX:
0010F7EE                          1070      ds.l    1
0010F7F2                          1071  ballVelocityY:
0010F7F2                          1072      ds.l    1 
0010F7F6                          1073  ; The score of the player for the current game
0010F7F6                          1074  score:
0010F7F6                          1075      ds.l    1     
0010F7FA                          1076  ; Amount of time taken to execute the previous frame
0010F7FA                          1077  deltaTime:
0010F7FA                          1078      ds.w    1
0010F7FC                          1079  ; The time at which the current frame started executing
0010F7FC                          1080  currentFrameTime:
0010F7FC                          1081      ds.l    1
0010F800                          1082  ballSpawnDirection:
0010F800                          1083      ds.b    1                       ; Indicates direction of ball spawn for values 1 (top), 2 (bot), 3 (left), 4 (right)    
0010F801                          1084  ballSound:
0010F801= 6E 65 62 65 6C 77 ...   1085      dc.b    'nebelwerferSound.wav', 0     
0010F816                          1086  jumpSound:
0010F816= 6A 75 6D 70 2E 77 ...   1087      dc.b    'jump.wav', 0    
0010F81F                          1088  
0010F81F                          1089  HAVE_HAD_NO_INPUT   ds.b    1       ; Boolean to check if there has been an instance where there was no user input
0010F820                          1090  UP_INPUT            ds.b    1       ; Boolean to check if the up arrow key was pressed
0010F821                          1091  DOWN_INPUT          ds.b    1       ; Boolean to check if the down arrow key was pressed
0010F822                          1092  LEFT_INPUT          ds.b    1       ; Boolean to check if the left arrow key was pressed
0010F823                          1093  RIGHT_INPUT         ds.b    1       ; Boolean to check if the right arrow key was pressed
0010F824                          1094  BALL_ISNT_IN_PLAY   ds.b    1       ; Boolean to check if the ball is out of the screen area
0010F825                          1095  GAME_LOST           ds.b    1       ; Boolean to check if the game was lost
0010F826                          1096  
0010F826                          1097      END    START

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
AFTERPADDING        194C
AROUNDNOINPUT       10B2
ARROW_KEYS_INPUT    25262728
BALLOUTFORBOTSPAWN  176A
BALLOUTFORLEFTSPAWN  1788
BALLOUTFORRIGHTSPAWN  17A6
BALLOUTFORTOPSPAWN  174C
BALLPOSITIONX       10F7E6
BALLPOSITIONY       10F7EA
BALLSOUND           10F801
BALLSPAWNDIRECTION  10F800
BALLSPAWNSFROMBOT   155E
BALLSPAWNSFROMLEFT  1590
BALLSPAWNSFROMRIGHT  15CC
BALLSPAWNSFROMTOP   152C
BALLSPRITE          78730
BALLVELOCITYBOT     163C
BALLVELOCITYLEFT    1648
BALLVELOCITYRIGHT   1654
BALLVELOCITYTOP     1630
BALLVELOCITYX       10F7EE
BALLVELOCITYY       10F7F2
BALL_ISNT_IN_PLAY   10F824
CHECKFORCOLLISION   17FE
CHECKIFBALLISINPLAY  171C
CHECKPLAYERPOSITION  1484
CLEARBALLFROMDISPLAY  16BA
CLEARPLAYERFROMDISPLAY  133A
COLOR               C0C0C0
COLORARRAY          1A0A
CONTINUEPLAYWITHCURRENTBALL  17C4
CURRENTFRAMETIME    10F7FC
DELTATIME           10F7FA
DEVIATEBALLPATHX    1660
DEVIATEBALLPATHY    1680
DEVIATION_IN_PATH   28
DIGITTABLE          1B96
DISPLACEMENT_BETWEEN_LED  3C
DISPLAYINGLEDNOTREQUIRED  1B82
DISPLAYLEDS         1B4E
DISPLAYLOOP         1AC2
DISPLAYNUMBER       1ABA
DISPLAYNUMBERONLEDS  1A4E
DISPLAYVALUEONLEDS  1B20
DONTDIVIDE          1AF0
DOUBLEDIGITSCORE    1A9E
DOWNKEYNOTPRESSED   12C8
DOWN_INPUT          10F821
DRAWING_MODE_TRAP_CODE  5C
DRAW_LINE_TRAP_CODE  54
DRAW_PIXEL_TRAP_CODE  52
ENABLEDOUBLEBUFFERING  10D2
ENDSCREEN           78F66
ESTIMATEDELTATIME   125A
GAMEBACKGROUND      1BC4
GAMELOOP            1068
GAMELOSECONDITION   11E8
GAME_LOST           10F825
GETARROWKEYSINPUT   1274
GETRANDOMBYTEINTOD6  1A2A
GET_PLAYER_INPUT_TRAP_CODE  13
HALT_SIM_TRAP_CODE  9
HAVE_HAD_NO_INPUT   10F81F
HEIGHT_S            14
IMAGEHEIGHT         1A12
IMAGEWIDTH          1A0E
IMAGE_USED_REG      46F7
INITIALIZEBALLDATA  14E6
INITIALIZEVARIABLES  1112
INSTANTIATEBALL     14C8
JUMPSOUND           10F816
LEDDISPLAYOFFSETTABLE  1BA0
LED_USED_REG        37F
LEFTKEYNOTPRESSED   12E6
LEFT_INPUT          10F822
LENGTHOFNUMBER      1BC0
LITTLETOBIG         19FE
LOADBACKGROUND      10DA
LOADBALL            17C6
LOADENDSCREEN       1222
LOADIMAGE           18B2
LOADPLAYER          11B0
NINC0               1A34
NINC1               1A3C
NOCHANGEINDOWNVELOCITY  13CA
NOCHANGEINLEFTVELOCITY  13F6
NOCHANGEINPLAYERPOSITION  1332
NOCHANGEINRIGHTVELOCITY  1422
NOCHANGEINUPVELOCITY  139E
NOCOLLISIONCHECKREQUIRED  1876
NOINPUT             10AA
PADDINGCOUNT        1A16
PEN_COLOR_TRAP_CODE  50
PEN_WIDTH           5
PEN_WIDTH_TRAP_CODE  5D
PIXELARRAY          1A06
PIXELSKIPPED        19B8
PLAYBALLSOUND       189A
PLAYERINPUT         10F7D2
PLAYEROUTOFDISPLAY  14BE
PLAYERPOSITIONX     10F7D6
PLAYERPOSITIONY     10F7DA
PLAYERSPRITE        772FA
PLAYERVELOCITYX     10F7DE
PLAYERVELOCITYY     10F7E2
PLAYJUMPSOUND       18A6
PLAY_SOUND_TRAP_CODE  49
PRINTINGONDISPLAY   198E
RANDOMVAL           1A4A
REPAINT_SCREEN_TRAP_CODE  5E
RESETINPUTBOOLEANS  1878
RESETPADDING        19F0
RESETPLAYERVELOCITYX  143E
RESETPLAYERVELOCITYY  144C
RIGHTKEYNOTPRESSED  1304
RIGHT_INPUT         10F823
SCORE               10F7F6
SCORENOTDISPLAYED   1B14
SEEDRANDOMNUMBER    1A1A
SETBALLVELOCITY     15FE
SETPLAYERVELOCITY   1286
SINGLEDIGITSCORE    1A90
SKIPINCREASINGADDRESS  1B84
SKIPINSTANTIATINGBALL  14E4
SOURCE_IMAGE_LOC_S  4
SPACE_INPUT         20
START               1000
STARTSCREEN         C439C
TEMPDATA            1BBC
TIME_SINCE_MIDNIGHT_TRAP_CODE  8
TOP_LEFT_X          0
TOP_LEFT_X_S        8
TOP_LEFT_Y          190
TOP_LEFT_Y_S        C
TRIPLEDIGITSCORE    1AAC
UPDATEBALLONDISPLAY  16A0
UPDATEBALLPOSITION  16F2
UPDATEPLAYERONDISPLAY  130C
UPDATEPLAYERPOSITION  145A
UPDATEPLAYERVELOCITY  1372
UPKEYNOTPRESSED     12AA
UP_INPUT            10F820
VALUE_FOR_SUBROUTINE  164
VALUE_FOR_SUBROUTINE_S  4
WAITFORGAMESTART    1042
WIDTH_S             10
XDIFFERENCEISPOSITIVE  183E
X_DESTINATION_S     18
X_SOURCE_S          8
YDIFFERENCEISPOSITIVE  184A
Y_DESTINATION_S     1C
Y_SOURCE_S          C
